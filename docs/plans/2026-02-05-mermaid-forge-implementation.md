# Mermaid Forge Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a Confluence Forge macro app that renders Mermaid diagrams with inline editing (split-pane live preview) and external URL source support.

**Architecture:** Forge Custom UI app with a macro module. React frontend handles Mermaid.js rendering and CodeMirror editing. Forge resolver backend handles external URL fetching. Macro config stores diagram source, mode, and URL settings via `view.getContext()` / `view.submit()`.

**Tech Stack:** TypeScript, React, Mermaid.js, CodeMirror, Atlassian Forge (Custom UI, Resolver, Storage API)

**Security Note:** Mermaid.js render output is SVG generated by the library with `securityLevel: 'strict'`. We use Mermaid's own render API (`mermaid.render()`) which produces sanitized SVG. The SVG is inserted via a dedicated container ref. This is the standard and recommended approach per Mermaid.js documentation.

---

### Task 1: Install Forge CLI and Scaffold Project

**Files:**
- Create: `mermaid-forge/manifest.yml`
- Create: `mermaid-forge/package.json`
- Create: `mermaid-forge/src/resolvers/index.ts`
- Create: `mermaid-forge/static/` (React app)

**Step 1: Install Forge CLI globally**

Run: `npm install -g @forge/cli`
Expected: Forge CLI installed, `forge --version` outputs version number

**Step 2: Create Forge app**

Run from `~/personal-projects/mermaid-forge`:
```bash
forge create --template confluence-macro-custom-ui
```
When prompted:
- App name: `mermaid-forge`

Expected: Scaffold created with `manifest.yml`, `src/`, `static/` directories.

**Step 3: Verify scaffold structure**

Run: `ls -la` and `cat manifest.yml`
Expected: Standard Forge Custom UI scaffold with macro module, resolver, and static React app.

**Step 4: Commit**

```bash
git init && git add -A && git commit -m "chore: scaffold Forge Custom UI macro app"
```

---

### Task 2: Configure Manifest with Macro Config and Permissions

**Files:**
- Modify: `manifest.yml`

**Step 1: Update manifest.yml to the full macro config**

Replace the entire `manifest.yml` with:

```yaml
modules:
  macro:
    - key: mermaid-diagram
      resource: main
      resolver:
        function: resolver
      title: Mermaid Diagram
      description: Render Mermaid diagrams natively in Confluence
      categories:
        - visuals
        - development
      config:
        resource: config
        viewportSize: xlarge
        title: Edit Mermaid Diagram
        openOnInsert: true
      layout: block
  function:
    - key: resolver
      handler: index.handler
resources:
  - key: main
    path: static/mermaid-forge/build
  - key: config
    path: static/config/build
permissions:
  scopes:
    - storage:app
  external:
    fetch:
      backend:
        - '*.githubusercontent.com'
        - '*.github.com'
        - '*.gitlab.com'
        - '*.bitbucket.org'
app:
  runtime:
    name: nodejs22.x
  id: ari:cloud:ecosystem::app/to-be-generated
```

Key details:
- Two resources: `main` (macro view) and `config` (configuration panel)
- `config.openOnInsert: true` opens config panel on first insertion
- `config.viewportSize: xlarge` gives the split-pane editor enough room
- `storage:app` permission for caching external URL content
- External fetch allows common Git hosting raw URLs
- `layout: block` makes the macro a full-width block element

**Step 2: Commit**

```bash
git add manifest.yml && git commit -m "feat: configure manifest with macro config and external fetch permissions"
```

---

### Task 3: Set Up Backend Resolver

**Files:**
- Create: `src/resolvers/index.ts`
- Modify: `package.json` (root — add @forge/api, @forge/resolver)

**Step 1: Install backend dependencies**

Run from project root:
```bash
npm install @forge/resolver @forge/api
```

**Step 2: Write the resolver with fetchExternalUrl and cache logic**

Create `src/resolvers/index.ts`:

```typescript
import Resolver from '@forge/resolver';
import { fetch } from '@forge/api';
import { storage } from '@forge/api';

const resolver = new Resolver();

interface CachedContent {
  content: string;
  fetchedAt: number;
  url: string;
}

const REFRESH_MS: Record<string, number> = {
  '1h': 3600000,
  '6h': 21600000,
  '24h': 86400000,
  '7d': 604800000,
};

resolver.define('fetchExternalUrl', async (req) => {
  const { url, refreshInterval, macroId } = req.payload;

  if (!url || typeof url !== 'string') {
    return { error: 'No URL provided' };
  }

  // Check cache
  const cacheKey = `mermaid-cache-${macroId}`;
  const cached = await storage.get(cacheKey) as CachedContent | undefined;

  if (cached && refreshInterval !== 'manual') {
    const maxAge = REFRESH_MS[refreshInterval];
    if (maxAge && Date.now() - cached.fetchedAt < maxAge) {
      return { content: cached.content, fromCache: true, fetchedAt: cached.fetchedAt };
    }
  }

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'text/plain' },
    });

    if (!response.ok) {
      if (cached) {
        return { content: cached.content, fromCache: true, fetchedAt: cached.fetchedAt, warning: `Failed to refresh (HTTP ${response.status}). Showing cached version.` };
      }
      return { error: `Failed to fetch: HTTP ${response.status}` };
    }

    const content = await response.text();

    // Enforce 50KB limit
    if (content.length > 50000) {
      return { error: 'Content exceeds 50KB limit' };
    }

    // Cache the result
    const cacheEntry: CachedContent = { content, fetchedAt: Date.now(), url };
    await storage.set(cacheKey, cacheEntry);

    return { content, fromCache: false, fetchedAt: Date.now() };
  } catch (err) {
    if (cached) {
      return { content: cached.content, fromCache: true, fetchedAt: cached.fetchedAt, warning: 'Network error. Showing cached version.' };
    }
    return { error: `Network error: ${err instanceof Error ? err.message : 'Unknown'}` };
  }
});

export const handler = resolver.getDefinitions();
```

**Step 3: Verify TypeScript compiles**

Run: `npx tsc --noEmit src/resolvers/index.ts` (or however the scaffold sets up TS)
Expected: No errors

**Step 4: Commit**

```bash
git add src/ package.json package-lock.json && git commit -m "feat: add resolver with external URL fetch and caching"
```

---

### Task 4: Set Up Custom UI React Apps (Main + Config)

**Files:**
- Create: `static/mermaid-forge/` (main macro view React app)
- Create: `static/config/` (config panel React app)

**Step 1: Create the main macro view React app**

```bash
cd static
npx create-react-app mermaid-forge --template typescript
cd mermaid-forge
npm install mermaid @forge/bridge
```

**Step 2: Create the config panel React app**

```bash
cd static
npx create-react-app config --template typescript
cd config
npm install mermaid @forge/bridge @codemirror/view @codemirror/state @codemirror/lang-markdown @codemirror/language @codemirror/theme-one-dark @codemirror/commands
```

**Step 3: Verify both apps build**

```bash
cd static/mermaid-forge && npm run build
cd static/config && npm run build
```

Expected: Both produce `build/` directories

**Step 4: Commit**

```bash
git add static/ && git commit -m "feat: scaffold main and config React apps with dependencies"
```

---

### Task 5: Build the Mermaid Renderer Component

**Files:**
- Create: `static/mermaid-forge/src/components/MermaidRenderer.tsx`
- Create: `static/mermaid-forge/src/hooks/useMermaid.ts`

**Step 1: Create useMermaid hook**

Create `static/mermaid-forge/src/hooks/useMermaid.ts`:

```typescript
import { useEffect, useRef, useCallback, useState } from 'react';
import mermaid from 'mermaid';

interface UseMermaidOptions {
  theme?: 'default' | 'dark' | 'forest' | 'neutral';
}

export function useMermaid(options: UseMermaidOptions = {}) {
  const [error, setError] = useState<string | null>(null);
  const initialized = useRef(false);

  useEffect(() => {
    if (!initialized.current) {
      mermaid.initialize({
        startOnLoad: false,
        securityLevel: 'strict',
        theme: options.theme || 'default',
        maxTextSize: 50000,
      });
      initialized.current = true;
    }
  }, [options.theme]);

  const render = useCallback(async (code: string, container: HTMLElement) => {
    setError(null);
    if (!code.trim()) {
      container.textContent = '';
      return;
    }
    try {
      const id = `mermaid-${Date.now()}`;
      const { svg } = await mermaid.render(id, code);
      // Mermaid.render() with securityLevel:'strict' produces sanitized SVG.
      // This is the official Mermaid.js API for rendering diagrams into the DOM.
      container.innerHTML = svg;
    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Invalid Mermaid syntax';
      setError(msg);
      container.textContent = '';
    }
  }, []);

  return { render, error };
}
```

**Step 2: Create MermaidRenderer component**

Create `static/mermaid-forge/src/components/MermaidRenderer.tsx`:

```tsx
import React, { useRef, useEffect } from 'react';
import { useMermaid } from '../hooks/useMermaid';

interface MermaidRendererProps {
  code: string;
  theme?: 'default' | 'dark';
  onError?: (error: string | null) => void;
}

export function MermaidRenderer({ code, theme = 'default', onError }: MermaidRendererProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const { render, error } = useMermaid({ theme });

  useEffect(() => {
    if (containerRef.current) {
      render(code, containerRef.current);
    }
  }, [code, render]);

  useEffect(() => {
    onError?.(error);
  }, [error, onError]);

  return (
    <div style={{ width: '100%', overflow: 'auto' }}>
      <div ref={containerRef} />
      {error && (
        <div style={{ color: '#de350b', padding: '8px 12px', fontSize: '13px', background: '#ffebe6', borderRadius: '3px', marginTop: '8px' }}>
          {error}
        </div>
      )}
    </div>
  );
}
```

**Step 3: Commit**

```bash
git add static/mermaid-forge/src/ && git commit -m "feat: add MermaidRenderer component and useMermaid hook"
```

---

### Task 6: Build the Theme Detection Hook

**Files:**
- Create: `static/mermaid-forge/src/hooks/useThemeDetect.ts`

**Step 1: Create useThemeDetect hook**

This detects whether Confluence is in light or dark mode by checking the iframe's document attributes.

Create `static/mermaid-forge/src/hooks/useThemeDetect.ts`:

```typescript
import { useState, useEffect } from 'react';

type Theme = 'default' | 'dark';

export function useThemeDetect(): Theme {
  const [theme, setTheme] = useState<Theme>('default');

  useEffect(() => {
    const detectTheme = () => {
      const isDark =
        document.documentElement.getAttribute('data-color-mode') === 'dark' ||
        document.body.getAttribute('data-color-mode') === 'dark' ||
        window.matchMedia('(prefers-color-scheme: dark)').matches;
      setTheme(isDark ? 'dark' : 'default');
    };

    detectTheme();

    const mq = window.matchMedia('(prefers-color-scheme: dark)');
    mq.addEventListener('change', detectTheme);

    const observer = new MutationObserver(detectTheme);
    observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-color-mode'] });
    observer.observe(document.body, { attributes: true, attributeFilter: ['data-color-mode'] });

    return () => {
      mq.removeEventListener('change', detectTheme);
      observer.disconnect();
    };
  }, []);

  return theme;
}
```

**Step 2: Commit**

```bash
git add static/mermaid-forge/src/hooks/ && git commit -m "feat: add Confluence theme detection hook"
```

---

### Task 7: Build the Main Macro View (App.tsx)

**Files:**
- Modify: `static/mermaid-forge/src/App.tsx`

**Step 1: Write the main macro view**

This component reads config from `view.getContext()` and renders the Mermaid diagram. For URL mode, it invokes the resolver to fetch content.

Replace `static/mermaid-forge/src/App.tsx`:

```tsx
import React, { useEffect, useState } from 'react';
import { view, invoke } from '@forge/bridge';
import { MermaidRenderer } from './components/MermaidRenderer';
import { useThemeDetect } from './hooks/useThemeDetect';

const DEFAULT_DIAGRAM = `graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Do something]
    B -->|No| D[Do something else]
    C --> E[End]
    D --> E`;

interface MacroConfig {
  sourceMode?: 'inline' | 'url';
  mermaidCode?: string;
  externalUrl?: string;
  refreshInterval?: string;
}

interface FetchResult {
  content?: string;
  error?: string;
  warning?: string;
  fromCache?: boolean;
  fetchedAt?: number;
}

function App() {
  const [code, setCode] = useState('');
  const [warning, setWarning] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const theme = useThemeDetect();

  useEffect(() => {
    const loadContent = async () => {
      try {
        const context = await view.getContext();
        const config = (context.extension?.config || {}) as MacroConfig;

        if (!config.sourceMode || config.sourceMode === 'inline') {
          setCode(config.mermaidCode || DEFAULT_DIAGRAM);
        } else if (config.sourceMode === 'url' && config.externalUrl) {
          const result: FetchResult = await invoke('fetchExternalUrl', {
            url: config.externalUrl,
            refreshInterval: config.refreshInterval || 'manual',
            macroId: context.localId,
          });
          if (result.error) {
            setWarning(result.error);
            setCode('');
          } else {
            setCode(result.content || '');
            if (result.warning) setWarning(result.warning);
          }
        } else {
          setCode(DEFAULT_DIAGRAM);
        }
      } catch (err) {
        setCode(DEFAULT_DIAGRAM);
      } finally {
        setLoading(false);
      }
    };

    loadContent();
  }, []);

  if (loading) {
    return <div style={{ padding: '16px', color: '#6b778c' }}>Loading diagram...</div>;
  }

  return (
    <div style={{ padding: '8px 0' }}>
      {warning && (
        <div style={{ padding: '8px 12px', marginBottom: '8px', background: '#fffae6', color: '#172b4d', borderRadius: '3px', fontSize: '13px', border: '1px solid #ffe380' }}>
          {warning}
        </div>
      )}
      <MermaidRenderer code={code} theme={theme} />
    </div>
  );
}

export default App;
```

**Step 2: Build and verify**

Run: `cd static/mermaid-forge && npm run build`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add static/mermaid-forge/src/ && git commit -m "feat: add main macro view with inline and URL rendering"
```

---

### Task 8: Build the CodeMirror Editor Component

**Files:**
- Create: `static/config/src/components/CodeEditor.tsx`

**Step 1: Create CodeEditor component**

Create `static/config/src/components/CodeEditor.tsx`:

```tsx
import React, { useRef, useEffect } from 'react';
import { EditorView, keymap, lineNumbers, highlightActiveLine } from '@codemirror/view';
import { EditorState } from '@codemirror/state';
import { markdown } from '@codemirror/lang-markdown';
import { defaultKeymap } from '@codemirror/commands';
import { oneDark } from '@codemirror/theme-one-dark';

interface CodeEditorProps {
  value: string;
  onChange: (value: string) => void;
  darkMode?: boolean;
}

export function CodeEditor({ value, onChange, darkMode = false }: CodeEditorProps) {
  const editorRef = useRef<HTMLDivElement>(null);
  const viewRef = useRef<EditorView | null>(null);

  useEffect(() => {
    if (!editorRef.current) return;

    const extensions = [
      lineNumbers(),
      highlightActiveLine(),
      markdown(),
      keymap.of(defaultKeymap),
      EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          onChange(update.state.doc.toString());
        }
      }),
      EditorView.theme({
        '&': { height: '100%', fontSize: '14px' },
        '.cm-scroller': { overflow: 'auto' },
        '.cm-content': { fontFamily: 'monospace' },
      }),
    ];

    if (darkMode) {
      extensions.push(oneDark);
    }

    const state = EditorState.create({ doc: value, extensions });
    const editorView = new EditorView({ state, parent: editorRef.current });
    viewRef.current = editorView;

    return () => editorView.destroy();
    // Only create editor once on mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [darkMode]);

  return <div ref={editorRef} style={{ height: '100%', border: '1px solid #dfe1e6', borderRadius: '3px' }} />;
}
```

**Step 2: Commit**

```bash
git add static/config/src/ && git commit -m "feat: add CodeMirror editor component"
```

---

### Task 9: Build the Split-Pane Editor and Source Mode Tabs

**Files:**
- Create: `static/config/src/components/SplitPaneEditor.tsx`
- Create: `static/config/src/components/SourceModeTabs.tsx`
- Create: `static/config/src/components/UrlSourceConfig.tsx`
- Create: `static/config/src/components/MermaidRenderer.tsx` (copy for config app)
- Create: `static/config/src/hooks/useMermaid.ts` (copy for config app)

**Step 1: Copy MermaidRenderer and useMermaid to config app**

The config app needs its own copy since it's a separate React build. Copy the same files from Task 5.

Create `static/config/src/hooks/useMermaid.ts` — same content as Task 5 Step 1.
Create `static/config/src/components/MermaidRenderer.tsx` — same content as Task 5 Step 2.

**Step 2: Create SourceModeTabs component**

Create `static/config/src/components/SourceModeTabs.tsx`:

```tsx
import React from 'react';

interface SourceModeTabsProps {
  mode: 'inline' | 'url';
  onChange: (mode: 'inline' | 'url') => void;
}

export function SourceModeTabs({ mode, onChange }: SourceModeTabsProps) {
  const tabStyle = (active: boolean): React.CSSProperties => ({
    padding: '8px 16px',
    cursor: 'pointer',
    borderBottom: active ? '2px solid #0052cc' : '2px solid transparent',
    color: active ? '#0052cc' : '#6b778c',
    fontWeight: active ? 600 : 400,
    fontSize: '14px',
    background: 'none',
    border: 'none',
    borderBottomWidth: '2px',
    borderBottomStyle: 'solid',
    borderBottomColor: active ? '#0052cc' : 'transparent',
  });

  return (
    <div style={{ display: 'flex', borderBottom: '1px solid #dfe1e6', marginBottom: '12px' }}>
      <button style={tabStyle(mode === 'inline')} onClick={() => onChange('inline')}>
        Inline Editor
      </button>
      <button style={tabStyle(mode === 'url')} onClick={() => onChange('url')}>
        External URL
      </button>
    </div>
  );
}
```

**Step 3: Create UrlSourceConfig component**

Create `static/config/src/components/UrlSourceConfig.tsx`:

```tsx
import React from 'react';

interface UrlSourceConfigProps {
  url: string;
  refreshInterval: string;
  onUrlChange: (url: string) => void;
  onRefreshChange: (interval: string) => void;
}

const REFRESH_OPTIONS = [
  { value: 'manual', label: 'Manual only' },
  { value: '1h', label: 'Every hour' },
  { value: '6h', label: 'Every 6 hours' },
  { value: '24h', label: 'Every 24 hours' },
  { value: '7d', label: 'Every 7 days' },
];

export function UrlSourceConfig({ url, refreshInterval, onUrlChange, onRefreshChange }: UrlSourceConfigProps) {
  const labelStyle: React.CSSProperties = { display: 'block', fontSize: '12px', fontWeight: 600, color: '#6b778c', marginBottom: '4px' };
  const inputStyle: React.CSSProperties = { width: '100%', padding: '8px', fontSize: '14px', border: '1px solid #dfe1e6', borderRadius: '3px', boxSizing: 'border-box' };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '16px', padding: '16px' }}>
      <div>
        <label style={labelStyle}>Raw file URL</label>
        <input
          type="url"
          value={url}
          onChange={(e) => onUrlChange(e.target.value)}
          placeholder="https://raw.githubusercontent.com/user/repo/main/diagram.mmd"
          style={inputStyle}
        />
        <div style={{ fontSize: '12px', color: '#6b778c', marginTop: '4px' }}>
          Paste the raw URL to a .mmd or text file containing Mermaid syntax
        </div>
      </div>
      <div>
        <label style={labelStyle}>Refresh interval</label>
        <select value={refreshInterval} onChange={(e) => onRefreshChange(e.target.value)} style={{ ...inputStyle, cursor: 'pointer' }}>
          {REFRESH_OPTIONS.map((opt) => (
            <option key={opt.value} value={opt.value}>{opt.label}</option>
          ))}
        </select>
      </div>
    </div>
  );
}
```

**Step 4: Create SplitPaneEditor component**

Create `static/config/src/components/SplitPaneEditor.tsx`:

```tsx
import React from 'react';
import { CodeEditor } from './CodeEditor';
import { MermaidRenderer } from './MermaidRenderer';

interface SplitPaneEditorProps {
  code: string;
  onChange: (code: string) => void;
  darkMode?: boolean;
}

export function SplitPaneEditor({ code, onChange, darkMode = false }: SplitPaneEditorProps) {
  return (
    <div style={{ display: 'flex', height: 'calc(100vh - 160px)', gap: '12px' }}>
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
        <div style={{ fontSize: '12px', fontWeight: 600, color: '#6b778c', marginBottom: '4px' }}>
          Mermaid Syntax
        </div>
        <div style={{ flex: 1 }}>
          <CodeEditor value={code} onChange={onChange} darkMode={darkMode} />
        </div>
      </div>
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
        <div style={{ fontSize: '12px', fontWeight: 600, color: '#6b778c', marginBottom: '4px' }}>
          Preview
        </div>
        <div style={{ flex: 1, border: '1px solid #dfe1e6', borderRadius: '3px', padding: '12px', overflow: 'auto', background: darkMode ? '#1b2638' : '#fff' }}>
          <MermaidRenderer code={code} theme={darkMode ? 'dark' : 'default'} />
        </div>
      </div>
    </div>
  );
}
```

**Step 5: Commit**

```bash
git add static/config/src/ && git commit -m "feat: add split-pane editor, source mode tabs, and URL config components"
```

---

### Task 10: Build the Config Panel App

**Files:**
- Modify: `static/config/src/App.tsx`

**Step 1: Write the config panel App**

Replace `static/config/src/App.tsx`:

```tsx
import React, { useEffect, useState } from 'react';
import { view } from '@forge/bridge';
import { SourceModeTabs } from './components/SourceModeTabs';
import { SplitPaneEditor } from './components/SplitPaneEditor';
import { UrlSourceConfig } from './components/UrlSourceConfig';

const DEFAULT_DIAGRAM = `graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Do something]
    B -->|No| D[Do something else]
    C --> E[End]
    D --> E`;

function App() {
  const [sourceMode, setSourceMode] = useState<'inline' | 'url'>('inline');
  const [mermaidCode, setMermaidCode] = useState(DEFAULT_DIAGRAM);
  const [externalUrl, setExternalUrl] = useState('');
  const [refreshInterval, setRefreshInterval] = useState('manual');
  const [loading, setLoading] = useState(true);

  // Load existing config on mount
  useEffect(() => {
    view.getContext().then((context) => {
      const config = context.extension?.config;
      if (config) {
        setSourceMode(config.sourceMode || 'inline');
        setMermaidCode(config.mermaidCode || DEFAULT_DIAGRAM);
        setExternalUrl(config.externalUrl || '');
        setRefreshInterval(config.refreshInterval || 'manual');
      }
      setLoading(false);
    });
  }, []);

  const handleSave = async () => {
    await view.submit({
      config: {
        sourceMode,
        mermaidCode,
        externalUrl,
        refreshInterval,
      },
    });
  };

  const handleCancel = () => {
    view.close();
  };

  if (loading) {
    return <div style={{ padding: '16px', color: '#6b778c' }}>Loading...</div>;
  }

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100vh', fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' }}>
      <SourceModeTabs mode={sourceMode} onChange={setSourceMode} />

      <div style={{ flex: 1, overflow: 'hidden' }}>
        {sourceMode === 'inline' ? (
          <SplitPaneEditor code={mermaidCode} onChange={setMermaidCode} />
        ) : (
          <UrlSourceConfig
            url={externalUrl}
            refreshInterval={refreshInterval}
            onUrlChange={setExternalUrl}
            onRefreshChange={setRefreshInterval}
          />
        )}
      </div>

      <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '8px', padding: '12px 16px', borderTop: '1px solid #dfe1e6' }}>
        <button onClick={handleCancel} style={{ padding: '8px 16px', fontSize: '14px', border: '1px solid #dfe1e6', borderRadius: '3px', background: '#fff', cursor: 'pointer' }}>
          Cancel
        </button>
        <button onClick={handleSave} style={{ padding: '8px 16px', fontSize: '14px', border: 'none', borderRadius: '3px', background: '#0052cc', color: '#fff', cursor: 'pointer', fontWeight: 500 }}>
          Save
        </button>
      </div>
    </div>
  );
}

export default App;
```

**Step 2: Build both apps**

```bash
cd static/config && npm run build
cd static/mermaid-forge && npm run build
```

Expected: Both build successfully

**Step 3: Commit**

```bash
git add static/ && git commit -m "feat: add config panel with source mode tabs, inline editor, and URL config"
```

---

### Task 11: Deploy and Test on Confluence

**Step 1: Register the app (first time only)**

```bash
forge register
```

**Step 2: Deploy the app**

```bash
forge deploy
```

Expected: Deployment succeeds, functions and static assets uploaded

**Step 3: Install the app on a Confluence site**

```bash
forge install --product confluence
```

When prompted, select your Confluence cloud site.

**Step 4: Test on Confluence**

1. Open a Confluence page in edit mode
2. Type `/Mermaid` and select the "Mermaid Diagram" macro
3. Verify: Config panel opens with split-pane editor
4. Verify: Default diagram renders in preview
5. Edit the Mermaid code — verify live preview updates
6. Switch to URL tab — verify URL input and refresh selector appear
7. Save — verify diagram renders on published page
8. Verify: Light/dark theme auto-detection works

**Step 5: Commit any fixes from testing**

```bash
git add -A && git commit -m "fix: post-deployment adjustments from testing"
```

---

### Task 12: Polish and Final Touches

**Step 1: Add empty state placeholder**

In both MermaidRenderer copies, ensure empty/undefined code shows the default flowchart example with a hint "Edit this diagram by clicking the macro".

**Step 2: Add loading states**

Ensure both the main view and config panel show appropriate loading indicators.

**Step 3: Final build and deploy**

```bash
cd static/mermaid-forge && npm run build
cd static/config && npm run build
forge deploy
```

**Step 4: Final commit**

```bash
git add -A && git commit -m "feat: polish empty states, loading indicators, and final touches"
```
